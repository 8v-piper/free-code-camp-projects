<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" type="text/css" href="style.css">
    <title>Document</title>
</head>
<body>
    <div class="flex-container">
        <nav id="navbar">
            <header class="nav-header">
                <img class="icon" src="angular.svg" alt="angular framework icon">
                <h1>Angular Docs</h1>
            </header>
            <ul>
                <li><a class="nav-link" href="#overview">Overview</a></li>
                <li><a class="nav-link" href="#Common routing tasks">Common routing tasks</a></li>
                <li><a class="nav-link" href="#Tutorial: Routing in single page application">Tutorial: Routing in single page application</a></li>
                <li><a class="nav-link" href="#Tutorial: Creating custom route matches">Tutorial: Creating custom route matches</a></li>
                <li><a class="nav-link" href="#Tutorial: Adding routing to Tour of Heroes">Tutorial: Adding routing to Tour of Heroes</a></li>
                <li><a class="nav-link" href="#Router reference">Router reference</a></li>
            </ul>
        </nav>
        <main id="main-doc">
            <section class="main-section">
                <header id="overview"><h1>Overview</h1></header>
                <h3>Angular Routing</h3>
                <P>
                    In a single-page app, you change what the user sees by showing or hiding portions of the display that correspond to particular components, rather than going out to the server to get a new page. As users perform application tasks, they need to move between the different views that you have defined.
                    To handle the navigation from one view to the next, you use the Angular Router. The Router enables navigation by interpreting a browser URL as an instruction to change the view.
                    To explore a sample app featuring the router's primary features, see the <a href="https://angular.io/generated/live-examples/router/stackblitz.html">live example</a>  / <a href="https://angular.io/generated/zips/router/router.zip">download example.</a> 
                </P>
                <h3>Prerequisites</h3>
                
                <h3>Before creating a route, you should be familiar with the following:</h3>
                <p>
                    <ul>
                        <li><a href="https://angular.io/guide/architecture-components">Basics of components</a></a></li>
                        <li><a href="https://angular.io/guide/glossary#template">Basics of templates</a></li>
                        <li>Angular app—you can generate a basic Angular app using the Angular CLI.</li>
                    </ul>
                </p>
            </section>
            <section class="main-section">
                <header id="common-routing-tasks">
                    
                </header>
                <h3>Common Routing Tasks</h3>
                <p>
                    This topic describes how to implement many of the common tasks associated with adding the Angular router to your application.
                </p>
                <h3>Generate an application with routing enabled</h3>
                <p>The following command uses the Angular CLI to generate a basic Angular application with an application routing module, called AppRoutingModule, which is an NgModule where you can configure your routes. The application name in the following example is routing-app.</p>
                <h3>content_copy</h3>
                <code>ng new routing-app --routing</code>
                <p>When generating a new application, the CLI prompts you to select CSS or a CSS preprocessor. For this example, accept the default of CSS.</p>
                <h3>Adding components for routing</h3>
                <p>To use the Angular router, an application needs to have at least two components so that it can navigate from one to the other. To create a component using the CLI, enter the following at the command line where first is the name of your component:</p>
                

                content_copy
                ng generate component first
                Repeat this step for a second component but give it a different name. Here, the new name is second.

                content_copy
                ng generate component second
                The CLI automatically appends Component, so if you were to write first-component, your component would be FirstComponentComponent.

                <base href>
                This guide works with a CLI-generated Angular application. If you are working manually, make sure that you have <base href="/"> in the <head> of your index.html file. This assumes that the app folder is the application root, and uses "/".

                Importing your new components
                To use your new components, import them into AppRoutingModule at the top of the file, as follows:

                AppRoutingModule (excerpt)
                content_copy
                import { FirstComponent } from './first/first.component';
                import { SecondComponent } from './second/second.component';
                Defining a basic route
                There are three fundamental building blocks to creating a route.

                Import the AppRoutingModule into AppModule and add it to the imports array.

                The Angular CLI performs this step for you. However, if you are creating an application manually or working with an existing, non-CLI application, verify that the imports and configuration are correct. The following is the default AppModule using the CLI with the --routing flag.

                Default CLI AppModule with routing
                content_copy
                import { BrowserModule } from '@angular/platform-browser';
                import { NgModule } from '@angular/core';
                import { AppRoutingModule } from './app-routing.module'; // CLI imports AppRoutingModule
                import { AppComponent } from './app.component';

                @NgModule({
                declarations: [
                    AppComponent
                ],
                imports: [
                    BrowserModule,
                    AppRoutingModule // CLI adds AppRoutingModule to the AppModule's imports array
                ],
                providers: [],
                bootstrap: [AppComponent]
                })
                export class AppModule { }
                Import RouterModule and Routes into your routing module.

                The Angular CLI performs this step automatically. The CLI also sets up a Routes array for your routes and configures the imports and exports arrays for @NgModule().

                CLI application routing module
                content_copy
                import { NgModule } from '@angular/core';
                import { Routes, RouterModule } from '@angular/router'; // CLI imports router

                const routes: Routes = []; // sets up routes constant where you define your routes

                // configures NgModule imports and exports
                @NgModule({
                imports: [RouterModule.forRoot(routes)],
                exports: [RouterModule]
                })
                export class AppRoutingModule { }
                Define your routes in your Routes array.

                Each route in this array is a JavaScript object that contains two properties. The first property, path, defines the URL path for the route. The second property, component, defines the component Angular should use for the corresponding path.

                AppRoutingModule (excerpt)
                content_copy
                const routes: Routes = [
                { path: 'first-component', component: FirstComponent },
                { path: 'second-component', component: SecondComponent },
                ];
                Add your routes to your application.

                Now that you have defined your routes, you can add them to your application. First, add links to the two components. Assign the anchor tag that you want to add the route to the routerLink attribute. Set the value of the attribute to the component to show when a user clicks on each link. Next, update your component template to include <router-outlet>. This element informs Angular to update the application view with the component for the selected route.

                Template with routerLink and router-outlet
                content_copy
                <h1>Angular Router App</h1>
                <!-- This nav gives you links to click, which tells the router which route to use (defined in the routes constant in  AppRoutingModule) -->
                <nav>
                <ul>
                    <li><a routerLink="/first-component" routerLinkActive="active">First Component</a></li>
                    <li><a routerLink="/second-component" routerLinkActive="active">Second Component</a></li>
                </ul>
                </nav>
                <!-- The routed views render in the <router-outlet>-->
                <router-outlet></router-outlet>
                Route order
                The order of routes is important because the Router uses a first-match wins strategy when matching routes, so more specific routes should be placed above less specific routes. List routes with a static path first, followed by an empty path route, which matches the default route. The wildcard route comes last because it matches every URL and the Router selects it only if no other routes match first.

                Getting route information
                Often, as a user navigates your application, you want to pass information from one component to another. For example, consider an application that displays a shopping list of grocery items. Each item in the list has a unique id. To edit an item, users click an Edit button, which opens an EditGroceryItem component. You want that component to retrieve the id for the grocery item so it can display the right information to the user.

                You can use a route to pass this type of information to your application components. To do so, you use the ActivatedRoute interface.

                To get information from a route:

                Import ActivatedRoute and ParamMap to your component.

                In the component class (excerpt)
                content_copy
                import { Router, ActivatedRoute, ParamMap } from '@angular/router';
                These import statements add several important elements that your component needs. To learn more about each, see the following API pages:

                Router
                ActivatedRoute
                ParamMap
                Inject an instance of ActivatedRoute by adding it to your application's constructor:

                In the component class (excerpt)
                content_copy
                constructor(
                private route: ActivatedRoute,
                ) {}
                Update the ngOnInit() method to access the ActivatedRoute and track the id parameter:

                In the component (excerpt)
                content_copy
                ngOnInit() {
                this.route.queryParams.subscribe(params => {
                    this.name = params['name'];
                });
                }
                Note: The preceding example uses a variable, name, and assigns it the value based on the name parameter.

                Setting up wildcard routes
                A well-functioning application should gracefully handle when users attempt to navigate to a part of your application that does not exist. To add this functionality to your application, you set up a wildcard route. The Angular router selects this route any time the requested URL doesn't match any router paths.

                To set up a wildcard route, add the following code to your routes definition.

                AppRoutingModule (excerpt)
                content_copy
                { path: '**', component:  }
                The two asterisks, **, indicate to Angular that this routes definition is a wildcard route. For the component property, you can define any component in your application. Common choices include an application-specific PageNotFoundComponent, which you can define to display a 404 page to your users; or a redirect to your application's main component. A wildcard route is the last route because it matches any URL. For more detail on why order matters for routes, see Route order.

                Displaying a 404 page
                To display a 404 page, set up a wildcard route with the component property set to the component you'd like to use for your 404 page as follows:

                AppRoutingModule (excerpt)
                content_copy
                const routes: Routes = [
                { path: 'first-component', component: FirstComponent },
                { path: 'second-component', component: SecondComponent },
                { path: '**', component: PageNotFoundComponent },  // Wildcard route for a 404 page
                ];
                The last route with the path of ** is a wildcard route. The router selects this route if the requested URL doesn't match any of the paths earlier in the list and sends the user to the PageNotFoundComponent.

                Setting up redirects
                To set up a redirect, configure a route with the path you want to redirect from, the component you want to redirect to, and a pathMatch value that tells the router how to match the URL.

                AppRoutingModule (excerpt)
                content_copy
                const routes: Routes = [
                { path: 'first-component', component: FirstComponent },
                { path: 'second-component', component: SecondComponent },
                { path: '',   redirectTo: '/first-component', pathMatch: 'full' }, // redirect to `first-component`
                { path: '**', component: PageNotFoundComponent },  // Wildcard route for a 404 page
                ];
                In this example, the third route is a redirect so that the router defaults to the first-component route. Notice that this redirect precedes the wildcard route. Here, path: '' means to use the initial relative URL ('').

                For more details on pathMatch see Spotlight on pathMatch.

                Nesting routes
                As your application grows more complex, you may want to create routes that are relative to a component other than your root component. These types of nested routes are called child routes. This means you're adding a second <router-outlet> to your app, because it is in addition to the <router-outlet> in AppComponent.

                In this example, there are two additional child components, child-a, and child-b. Here, FirstComponent has its own <nav> and a second <router-outlet> in addition to the one in AppComponent.

                In the template
                content_copy
                <h2>First Component</h2>

                <nav>
                <ul>
                    <li><a routerLink="child-a">Child A</a></li>
                    <li><a routerLink="child-b">Child B</a></li>
                </ul>
                </nav>

                <router-outlet></router-outlet>
                A child route is like any other route, in that it needs both a path and a component. The one difference is that you place child routes in a children array within the parent route.

                AppRoutingModule (excerpt)
                content_copy
                const routes: Routes = [
                {
                    path: 'first-component',
                    component: FirstComponent, // this is the component with the <router-outlet> in the template
                    children: [
                    {
                        path: 'child-a', // child route path
                        component: ChildAComponent, // child route component that the router renders
                    },
                    {
                        path: 'child-b',
                        component: ChildBComponent, // another child route component that the router renders
                    },
                    ],
                },
                ];
                Using relative paths
                Relative paths allow you to define paths that are relative to the current URL segment. The following example shows a relative route to another component, second-component. FirstComponent and SecondComponent are at the same level in the tree, however, the link to SecondComponent is situated within the FirstComponent, meaning that the router has to go up a level and then into the second directory to find the SecondComponent. Rather than writing out the whole path to get to SecondComponent, you can use the ../ notation to go up a level.

                In the template
                content_copy
                <h2>First Component</h2>

                <nav>
                <ul>
                    <li><a routerLink="../second-component">Relative Route to second component</a></li>
                </ul>
                </nav>
                <router-outlet></router-outlet>
                In addition to ../, you can use ./ or no leading slash to specify the current level.

                Specifying a relative route
                To specify a relative route, use the NavigationExtras relativeTo property. In the component class, import NavigationExtras from the @angular/router.

                Then use relativeTo in your navigation method. After the link parameters array, which here contains items, add an object with the relativeTo property set to the ActivatedRoute, which is this.route.

                RelativeTo
                content_copy
                goToItems() {
                this.router.navigate(['items'], { relativeTo: this.route });
                }
                The goToItems() method interprets the destination URI as relative to the activated route and navigates to the items route.

                Accessing query parameters and fragments
                Sometimes, a feature of your application requires accessing a part of a route, such as a query parameter or a fragment. The Tour of Heroes application at this stage in the tutorial uses a list view in which you can click on a hero to see details. The router uses an id to show the correct hero's details.

                First, import the following members in the component you want to navigate from.

                Component import statements (excerpt)
                content_copy
                import { ActivatedRoute } from '@angular/router';
                import { Observable } from 'rxjs';
                import { switchMap } from 'rxjs/operators';
                Next inject the activated route service:

                Component (excerpt)
                content_copy
                constructor(private route: ActivatedRoute) {}
                Configure the class so that you have an observable, heroes$, a selectedId to hold the id number of the hero, and the heroes in the ngOnInit(), add the following code to get the id of the selected hero. This code snippet assumes that you have a heroes list, a hero service, a function to get your heroes, and the HTML to render your list and details, just as in the Tour of Heroes example.

                Component 1 (excerpt)
                content_copy
                heroes$: Observable;
                selectedId: number;
                heroes = HEROES;

                ngOnInit() {
                this.heroes$ = this.route.paramMap.pipe(
                    switchMap(params => {
                    this.selectedId = Number(params.get('id'));
                    return this.service.getHeroes();
                    })
                );
                }
                Next, in the component that you want to navigate to, import the following members.

                Component 2 (excerpt)
                content_copy
                import { Router, ActivatedRoute, ParamMap } from '@angular/router';
                import { Observable } from 'rxjs';
                Inject ActivatedRoute and Router in the constructor of the component class so they are available to this component:

                Component 2 (excerpt)
                content_copy
                hero$: Observable;

                constructor(
                    private route: ActivatedRoute,
                    private router: Router  ) {}

                ngOnInit() {
                    const heroId = this.route.snapshot.paramMap.get('id');
                    this.hero$ = this.service.getHero(heroId);
                }

                gotoItems(hero: Hero) {
                    const heroId = hero ? hero.id : null;
                    // Pass along the hero id if available
                    // so that the HeroList component can select that item.
                    this.router.navigate(['/heroes', { id: heroId }]);
                }
                Lazy loading
                You can configure your routes to lazy load modules, which means that Angular only loads modules as needed, rather than loading all modules when the application launches. Additionally, you can preload parts of your application in the background to improve the user experience.

                For more information on lazy loading and preloading see the dedicated guide Lazy loading NgModules.

                Preventing unauthorized access
                Use route guards to prevent users from navigating to parts of an application without authorization. The following route guards are available in Angular:

                CanActivate
                CanActivateChild
                CanDeactivate
                Resolve
                CanLoad
                To use route guards, consider using component-less routes as this facilitates guarding child routes.

                Create a service for your guard:

                content_copy
                ng generate guard your-guard
                In your guard class, implement the guard you want to use. The following example uses CanActivate to guard the route.

                Component (excerpt)
                content_copy
                export class YourGuard implements CanActivate {
                canActivate(
                    next: ActivatedRouteSnapshot,
                    state: RouterStateSnapshot): boolean {
                    // your  logic goes here
                }
                }
                In your routing module, use the appropriate property in your routes configuration. Here, canActivate tells the router to mediate navigation to this particular route.

                Routing module (excerpt)
                content_copy
                {
                path: '/your-path',
                component: YourComponent,
                canActivate: [YourGuard],
                }
                For more information with a working example, see the routing tutorial section on route guards.

                Link parameters array
                A link parameters array holds the following ingredients for router navigation:

                The path of the route to the destination component.
                Required and optional route parameters that go into the route URL.
                You can bind the RouterLink directive to such an array like this:

                src/app/app.component.ts (h-anchor)
                content_copy
                <a [routerLink]="['/heroes']">Heroes</a>
                The following is a two-element array when specifying a route parameter:

                src/app/heroes/hero-list/hero-list.component.html (nav-to-detail)
                content_copy
                <a [routerLink]="['/hero', hero.id]">
                <span class="badge">{{ hero.id }}</span>{{ hero.name }}
                </a>
                You can provide optional route parameters in an object, as in { foo: 'foo' }:

                src/app/app.component.ts (cc-query-params)
                content_copy
                <a [routerLink]="['/crisis-center', { foo: 'foo' }]">Crisis Center</a>
                These three examples cover the needs of an application with one level of routing. However, with a child router, such as in the crisis center, you create new link array possibilities.

                The following minimal RouterLink example builds upon a specified default child route for the crisis center.

                src/app/app.component.ts (cc-anchor-w-default)
                content_copy
                <a [routerLink]="['/crisis-center']">Crisis Center</a>
                Note the following:

                The first item in the array identifies the parent route (/crisis-center).
                There are no parameters for this parent route.
                There is no default for the child route so you need to pick one.
                You're navigating to the CrisisListComponent, whose route path is /, but you don't need to explicitly add the slash.
                Consider the following router link that navigates from the root of the application down to the Dragon Crisis:

                src/app/app.component.ts (Dragon-anchor)
                content_copy
                <a [routerLink]="['/crisis-center', 1]">Dragon Crisis</a>
                The first item in the array identifies the parent route (/crisis-center).
                There are no parameters for this parent route.
                The second item identifies the child route details about a particular crisis (/:id).
                The details child route requires an id route parameter.
                You added the id of the Dragon Crisis as the second item in the array (1).
                The resulting path is /crisis-center/1.
                You could also redefine the AppComponent template with Crisis Center routes exclusively:

                src/app/app.component.ts (template)
                content_copy
                template: `
                <h1 class="title">Angular Router</h1>
                <nav>
                    <a [routerLink]="['/crisis-center']">Crisis Center</a>
                    <a [routerLink]="['/crisis-center/1', { foo: 'foo' }]">Dragon Crisis</a>
                    <a [routerLink]="['/crisis-center/2']">Shark Crisis</a>
                </nav>
                <router-outlet></router-outlet>
                `
                In summary, you can write applications with one, two or more levels of routing. The link parameters array affords the flexibility to represent any routing depth and any legal sequence of route paths, (required) router parameters, and (optional) route parameter objects.

                LocationStrategy and browser URL styles
                When the router navigates to a new component view, it updates the browser's location and history with a URL for that view.

                Modern HTML5 browsers support history.pushState, a technique that changes a browser's location and history without triggering a server page request. The router can compose a "natural" URL that is indistinguishable from one that would otherwise require a page load.

                Here's the Crisis Center URL in this "HTML5 pushState" style:

                content_copy
                localhost:3002/crisis-center/
                Older browsers send page requests to the server when the location URL changes unless the change occurs after a "#" (called the "hash"). Routers can take advantage of this exception by composing in-application route URLs with hashes. Here's a "hash URL" that routes to the Crisis Center.

                content_copy
                localhost:3002/src/#/crisis-center/
                The router supports both styles with two LocationStrategy providers:

                PathLocationStrategy—the default "HTML5 pushState" style.
                HashLocationStrategy—the "hash URL" style.
                The RouterModule.forRoot() function sets the LocationStrategy to the PathLocationStrategy, which makes it the default strategy. You also have the option of switching to the HashLocationStrategy with an override during the bootstrapping process.

                For more information on providers and the bootstrap process, see Dependency Injection.

                Choosing a routing strategy
                You must choose a routing strategy early in the development of your project because once the application is in production, visitors to your site use and depend on application URL references.

                Almost all Angular projects should use the default HTML5 style. It produces URLs that are easier for users to understand and it preserves the option to do server-side rendering.

                Rendering critical pages on the server is a technique that can greatly improve perceived responsiveness when the application first loads. An application that would otherwise take ten or more seconds to start could be rendered on the server and delivered to the user's device in less than a second.

                This option is only available if application URLs look like normal web URLs without hashes (#) in the middle.

                <base href>
                The router uses the browser's history.pushState for navigation. pushState allows you to customize in-application URL paths; for example, localhost:4200/crisis-center. The in-application URLs can be indistinguishable from server URLs.

                Modern HTML5 browsers were the first to support pushState which is why many people refer to these URLs as "HTML5 style" URLs.

                HTML5 style navigation is the router default. In the LocationStrategy and browser URL styles section, learn why HTML5 style is preferable, how to adjust its behavior, and how to switch to the older hash (#) style, if necessary.

                You must add a <base href> element to the application's index.html for pushState routing to work. The browser uses the <base href> value to prefix relative URLs when referencing CSS files, scripts, and images.

                Add the <base> element just after the <head> tag. If the app folder is the application root, as it is for this application, set the href value in index.html as shown here.

                src/index.html (base-href)
                content_copy
                <base href="/">
                HTML5 URLs and the <base href>
                The guidelines that follow will refer to different parts of a URL. This diagram outlines what those parts refer to:

                content_copy
                foo://example.com:8042/over/there?name=ferret#nose
                \_/   \______________/\_________/ \_________/ \__/
                |           |            |            |        |
                scheme    authority      path        query   fragment
                While the router uses the HTML5 pushState style by default, you must configure that strategy with a <base href>.

                The preferred way to configure the strategy is to add a <base href> element tag in the <head> of the index.html.

                src/index.html (base-href)
                content_copy
                <base href="/">
                Without that tag, the browser may not be able to load resources (images, CSS, scripts) when "deep linking" into the application.

                Some developers may not be able to add the <base> element, perhaps because they don't have access to <head> or the index.html.

                Those developers may still use HTML5 URLs by taking the following two steps:

                Provide the router with an appropriate APP_BASE_HREF value.
                Use root URLs (URLs with an authority) for all web resources: CSS, images, scripts, and template HTML files.
                The <base href> path should end with a "/", as browsers ignore characters in the path that follow the right-most "/".
                If the <base href> includes a query part, the query is only used if the path of a link in the page is empty and has no query. This means that a query in the <base href> is only included when using HashLocationStrategy.
                If a link in the page is a root URL (has an authority), the <base href> is not used. In this way, an APP_BASE_HREF with an authority will cause all links created by Angular to ignore the <base href> value.
                A fragment in the <base href> is never persisted.
                For more complete information on how <base href> is used to construct target URIs, see the RFC section on transforming references.

                HashLocationStrategy
                You can use HashLocationStrategy by providing the useHash: true in an object as the second argument of the RouterModule.forRoot() in the AppModule.

                src/app/app.module.ts (hash URL strategy)
                content_copy
                import { NgModule } from '@angular/core';
                import { BrowserModule } from '@angular/platform-browser';
                import { FormsModule } from '@angular/forms';
                import { Routes, RouterModule } from '@angular/router';

                import { AppComponent } from './app.component';
                import { PageNotFoundComponent } from './page-not-found/page-not-found.component';

                const routes: Routes = [

                ];

                @NgModule({
                imports: [
                    BrowserModule,
                    FormsModule,
                    RouterModule.forRoot(routes, { useHash: true })  // .../#/crisis-center/
                ],
                declarations: [
                    AppComponent,
                    PageNotFoundComponent
                ],
                providers: [

                ],
                bootstrap: [ AppComponent ]
                })
                export class AppModule { }
            </section>
            <section class="main-section">
                <header>
                    
                </header>
            </section>
            <section class="main-section">
                <header>
                    
                </header>
            </section>
            <section class="main-section">
                <header>
                    
                </header>
            </section>
            <section class="main-section">
                <header>
                    
                </header>
            </section>
        </main>
    </div>
</body>
</html>